// EMA Ribbon + MACD Hybrid Strategy v1.4.3 - EXPERIMENTAL
// Multi-layer signal system combining EMA ribbon trend analysis with MACD momentum
// Transformation target: Enhanced trend filtering + reduced false signals
//
// âš ï¸ EXPERIMENTAL WARNING: Testing lab only - paper trading required
//
// License: MIT License - Educational/Experimental Use Only
//
// Contributors:
// Â© Saty Mahajan - Original EMA Ribbon methodology (Webull adaptation)
// Â© TradingView Community - MACD methodology
// Â© Claude AI - Hybrid strategy implementation and Pine Script v6 conversion
// Â© iamrichardD - Testing lab validation and strategy refinement
//
//@version=6

strategy("EMA Ribbon MACD v1", "RIBBON_v1", overlay=false,
         default_qty_type=strategy.percent_of_equity, default_qty_value=2,
         commission_type=strategy.commission.percent, commission_value=0.05,
         slippage=1, calc_on_every_tick=true, calc_on_order_fills=true,
         max_bars_back=200, process_orders_on_close=false, scale=scale.right)

//=====================================================================================================================
// ðŸš§ EXPERIMENTAL WARNING
//=====================================================================================================================
// This is experimental development code in testing lab
// DO NOT USE FOR LIVE TRADING - PAPER TRADING ONLY
// Target: Enhanced trend filtering + superior signal quality

//=====================================================================================================================
// ðŸ›¡ï¸ RISK MANAGEMENT - PRIORITY 1 (ESSENTIAL)
//=====================================================================================================================
grpRisk = "ðŸ›¡ï¸ Risk Management"
stopLossPercent = input.float(1.5, "Stop Loss %", minval=0.5, maxval=3.0, step=0.1, group=grpRisk)
takeProfitPercent = input.float(2.5, "Take Profit %", minval=1.0, maxval=4.0, step=0.1, group=grpRisk)
maxDailyTrades = input.int(10, "Max Daily Trades", minval=3, maxval=50, group=grpRisk)

//=====================================================================================================================
// ðŸ“Š EMA RIBBON CONFIGURATION - PRIORITY 1 (ESSENTIAL)
//=====================================================================================================================
grpRibbon = "ðŸ“Š EMA Ribbon System"
fastEmaLen = input.int(8, "Fast EMA Length", minval=5, maxval=15, group=grpRibbon, tooltip="Primary trend EMA")
pivotEmaLen = input.int(21, "Pivot EMA Length", minval=15, maxval=30, group=grpRibbon, tooltip="Key support/resistance")
slowEmaLen = input.int(34, "Slow EMA Length", minval=25, maxval=50, group=grpRibbon, tooltip="Long-term trend filter")

//=====================================================================================================================
// ðŸŒŠ MACD MOMENTUM SYSTEM - PRIORITY 1 (ESSENTIAL)
//=====================================================================================================================
grpMACD = "ðŸŒŠ MACD Momentum"
macdFast = input.int(8, "MACD Fast", minval=6, maxval=15, group=grpMACD, tooltip="Proven 8,21,5 system")
macdSlow = input.int(21, "MACD Slow", minval=15, maxval=35, group=grpMACD)
macdSignal = input.int(5, "MACD Signal", minval=3, maxval=15, group=grpMACD)

//=====================================================================================================================
// ðŸŽ¯ MACD SIGNALS - PRIORITY 2 (STRATEGY TUNING)
//=====================================================================================================================
grpSignals = "ðŸŽ¯ MACD Signals"
useZeroCross = input.bool(true, "MACD Zero Cross", group=grpSignals)
useSignalCross = input.bool(true, "MACD Signal Cross", group=grpSignals)
useMomentumSignals = input.bool(false, "Early Momentum", group=grpSignals)
momentumThreshold = input.float(0.2, "Momentum Threshold", minval=0.05, maxval=0.5, step=0.05, group=grpSignals)


//=====================================================================================================================
// ðŸ”„ SIGNAL FILTERING - PRIORITY 2 (STRATEGY TUNING)
//=====================================================================================================================
grpFiltering = "ðŸ”„ Signal Filtering"
useSignalCooldown = input.bool(true, "Enable Signal Cooldown", group=grpFiltering, tooltip="Prevent rapid-fire signals")
earlyCooldownBars = input.int(1, "Early Signal Cooldown (bars)", minval=0, maxval=5, group=grpFiltering, tooltip="Cooldown for early signals - allows confirmation building")
standardCooldownBars = input.int(5, "Standard Signal Cooldown (bars)", minval=1, maxval=20, group=grpFiltering, tooltip="Cooldown for confirmed/standard signals")
allowConfirmationBypass = input.bool(true, "Allow Confirmation Bypass", group=grpFiltering, tooltip="Let confirmation system override cooldown restrictions")
useSignalStrength = input.bool(true, "Enable Signal Strength Filter", group=grpFiltering, tooltip="Only allow signals when conditions are strong")
preventRapidReversals = input.bool(true, "Prevent Rapid Reversals", group=grpFiltering, tooltip="Block opposite signals too quickly")
marketStructureMode = input.string("Pivot EMA", "Market Structure Level", options=["Pivot EMA", "SMA 20"], group=grpFiltering, tooltip="Pivot EMA = EMA-aligned (default), SMA 20 = Conservative testing")
useMarketStructureFilter = input.bool(true, "Enable Market Structure Filter", group=grpFiltering, tooltip="Require price above/below structure level for entries")

//=====================================================================================================================
// âœ… SIGNAL CONFIRMATION SYSTEM - PRIORITY 2 (STRATEGY TUNING)
//=====================================================================================================================
grpConfirmation = "âœ… Signal Confirmation System"
useSignalConfirmation = input.bool(true, "Enable Signal Confirmation", group=grpConfirmation, tooltip="Upgrade consecutive early signals to standard status")
confirmationWindow = input.int(5, "Confirmation Window (bars)", minval=1, maxval=10, group=grpConfirmation, tooltip="Time window for signal confirmation - wider window catches more patterns")
upgradeConfirmedSignals = input.bool(true, "Upgrade Confirmed to Standard", group=grpConfirmation, tooltip="Show confirmed signals as standard (green/red) instead of early")
requireSameDirection = input.bool(true, "Require Same Direction", group=grpConfirmation, tooltip="Only confirm signals in same direction")

// Early Entry System - moved to PRIORITY 3 (ADVANCED)
grpEarly = "âš¡ Early Entry System"
useEarlyEntry = input.bool(true, "Enable Early Entry Signals", group=grpEarly, tooltip="Catch high-probability setups before full confirmation")
useVolumeFilterEarly = input.bool(false, "Enable Volume Filter for Early Entry", group=grpEarly, tooltip="OFF = more signals, ON = higher quality")
useAggressiveMacd = input.bool(false, "Enable Aggressive MACD Threshold", group=grpEarly, tooltip="OFF = conservative (-0.15), ON = aggressive (-0.05)")
earlyReversalBars = input.int(2, "Reversal Pattern Bars", minval=1, maxval=5, group=grpEarly)
useSimpleReversal = input.bool(true, "Use Simple Reversal (vs Strict)", group=grpEarly, tooltip="More aggressive reversal detection")
useUltraEarly = input.bool(false, "Enable Ultra-Aggressive Mode", group=grpEarly, tooltip="Maximum sensitivity - catches more opportunities but may increase noise")
useMultiplePaths = input.bool(true, "Enable Multiple Entry Paths", group=grpEarly, tooltip="Alternative signal paths for better opportunity capture")

//=====================================================================================================================
// ðŸ“ˆ TRAILING STOP - PRIORITY 3 (ADVANCED)
//=====================================================================================================================
grpTrailing = "ðŸ“ˆ Trailing Stop"
useTrailingStop = input.bool(true, "Enable Trailing Stop", group=grpTrailing)
trailingActivation = input.float(0.8, "Activation %", minval=0.3, maxval=1.5, step=0.1, group=grpTrailing)
trailingDistance = input.float(0.4, "Trailing Distance %", minval=0.1, maxval=0.8, step=0.1, group=grpTrailing)

//=====================================================================================================================
// ðŸšª SMART EXIT SYSTEM - PRIORITY 2 (STRATEGY TUNING)
//=====================================================================================================================
grpSmartExit = "ðŸšª Smart Exit System"
useReversalExits = input.bool(true, "Enable Reversal Exits", group=grpSmartExit, tooltip="Auto-exit on technical reversal patterns")
useEmaBreakExits = input.bool(true, "Enable EMA Break Exits", group=grpSmartExit, tooltip="Exit when price breaks key EMA levels")
reversalSensitivity = input.float(0.7, "Reversal Sensitivity", minval=0.3, maxval=1.0, step=0.1, group=grpSmartExit, tooltip="0.3=Conservative, 1.0=Aggressive")
volumeConfirmation = input.bool(false, "Require Volume Confirmation", group=grpSmartExit, tooltip="Reversal must have volume > 1.2x average")
emaExitLevel = input.string("Fast EMA", "EMA Exit Level", options=["Fast EMA", "Pivot EMA", "Slow EMA"], group=grpSmartExit, tooltip="Which EMA break triggers exit")

//=====================================================================================================================
// ðŸ—ï¸ SMA CONTEXT LEVELS - PRIORITY 3 (ADVANCED)
//=====================================================================================================================
grpSma = "ðŸ—ï¸ SMA Context Levels"
useSmaFilter = input.bool(true, "Enable SMA Context Filter", group=grpSma)
sma50Len = input.int(50, "SMA 50 Length", minval=30, maxval=70, group=grpSma)
sma100Len = input.int(100, "SMA 100 Length", minval=80, maxval=120, group=grpSma)
sma200Len = input.int(200, "SMA 200 Length", minval=150, maxval=250, group=grpSma)

//=====================================================================================================================
// ðŸ” DEBUG & CALIBRATION - PRIORITY 4 (DEBUG/ADVANCED)
//=====================================================================================================================
grpDebug = "ðŸ” Debug & Calibration"
showPerformance = input.bool(true, "Show Performance Metrics", group=grpDebug, tooltip="Total trades, win rate, net profit")
showSignalStatus = input.bool(false, "Show Signal Status", group=grpDebug, tooltip="EMA ribbon, MACD status, SMA context")
showFilters = input.bool(false, "Show Filter Debug", group=grpDebug, tooltip="Signal filtering analysis")
showLayerBreakdown = input.bool(false, "Show Layer Breakdown", group=grpDebug, tooltip="Show why standard signals pass/fail each layer")
showSmartExit = input.bool(false, "Show Smart Exit Debug", group=grpDebug, tooltip="Exit system analysis")
showPatterns = input.bool(false, "Show Pattern Debug", group=grpDebug, tooltip="Candlestick pattern analysis")
showPosition = input.bool(false, "Show Position Management", group=grpDebug, tooltip="Trade management details")
standardLongColor = input.color(color.lime, "Standard Long Color", group=grpDebug, tooltip="Color for standard long signals")
standardShortColor = input.color(color.red, "Standard Short Color", group=grpDebug, tooltip="Color for standard short signals")
earlyLongColor = input.color(color.yellow, "Early Long Color", group=grpDebug, tooltip="Color for early long signals")
earlyShortColor = input.color(color.orange, "Early Short Color", group=grpDebug, tooltip="Color for early short signals")
hammerShadowRatio = input.float(0.4, "Hammer Shadow Ratio", minval=0.2, maxval=0.8, step=0.1, group=grpDebug, tooltip="Lower shadow must be this ratio of total range")
bodyToRangeRatio = input.float(0.4, "Body to Range Ratio", minval=0.2, maxval=0.6, step=0.1, group=grpDebug, tooltip="Body must be smaller than this ratio of total range")
upperShadowRatio = input.float(0.25, "Upper Shadow Ratio", minval=0.1, maxval=0.4, step=0.05, group=grpDebug, tooltip="Upper shadow must be smaller than this ratio")

//=====================================================================================================================
// ðŸ” SIGNAL FILTERS
//=====================================================================================================================
grpFilters = "ðŸ” Advanced Filters"
useVolumeFilter = input.bool(true, "Volume Filter", group=grpFilters)
volumeThreshold = input.float(1.3, "Volume Threshold (x avg)", minval=1.0, maxval=3.0, step=0.1, group=grpFilters)
useRibbonStrength = input.bool(true, "Ribbon Strength Filter", group=grpFilters, tooltip="All EMAs must be aligned")
minRibbonGap = input.float(0.1, "Min Ribbon Gap %", minval=0.05, maxval=0.5, step=0.05, group=grpFilters, tooltip="Minimum gap between EMAs")

//=====================================================================================================================
// ðŸ“Š EMA RIBBON CALCULATIONS
//=====================================================================================================================
// EMA Calculations
fastEma = ta.ema(close, fastEmaLen)
pivotEma = ta.ema(close, pivotEmaLen)
slowEma = ta.ema(close, slowEmaLen)

// SMA Context Levels
sma50 = ta.sma(close, sma50Len)
sma100 = ta.sma(close, sma100Len)
sma200 = ta.sma(close, sma200Len)

// EMA Ribbon Analysis (using previous bar to avoid look-ahead)
fastEmaPrev = fastEma[1]
pivotEmaPrev = pivotEma[1]
slowEmaPrev = slowEma[1]
closePrev = close[1]

bullishRibbon = fastEmaPrev > pivotEmaPrev and pivotEmaPrev > slowEmaPrev
bearishRibbon = fastEmaPrev < pivotEmaPrev and pivotEmaPrev < slowEmaPrev
ribbonAligned = bullishRibbon or bearishRibbon

// Ribbon Strength Analysis (using previous bar)
fastPivotGap = math.abs(fastEmaPrev - pivotEmaPrev) / closePrev * 100
pivotSlowGap = math.abs(pivotEmaPrev - slowEmaPrev) / closePrev * 100
ribbonStrengthOk = not useRibbonStrength or (fastPivotGap >= minRibbonGap and pivotSlowGap >= minRibbonGap)

// SMA Context Analysis (using previous bar)
sma50Prev = sma50[1]
sma200Prev = sma200[1]
longTermBullish = not useSmaFilter or (sma50Prev > sma200Prev and closePrev > sma50Prev)
longTermBearish = not useSmaFilter or (sma50Prev < sma200Prev and closePrev < sma50Prev)

//=====================================================================================================================
// ðŸŒŠ MACD MOMENTUM CALCULATIONS
//=====================================================================================================================
[macdLine, signalLine, histogramLine] = ta.macd(close, macdFast, macdSlow, macdSignal)

// MACD Signal Detection (previous bar to avoid repainting)
macdPrev = macdLine[1]
signalPrev = signalLine[1]
macdPrev2 = macdLine[2]
signalPrev2 = signalLine[2]

// Signal Types
macdZeroCrossUp = macdPrev > 0 and macdPrev2 <= 0
macdZeroCrossDown = macdPrev < 0 and macdPrev2 >= 0
macdSignalCrossUp = macdPrev > signalPrev and macdPrev2 <= signalPrev2
macdSignalCrossDown = macdPrev < signalPrev and macdPrev2 >= signalPrev2

// Early Momentum Signals (using previous bar to avoid look-ahead)
macdMomentumUp = useMomentumSignals and macdPrev > signalPrev and (macdPrev - macdPrev2) > momentumThreshold and macdPrev < 0
macdMomentumDown = useMomentumSignals and macdPrev < signalPrev and (macdPrev - macdPrev2) < -momentumThreshold and macdPrev > 0

//=====================================================================================================================
// ðŸŽ¯ MULTI-LAYER SIGNAL SYSTEM
//=====================================================================================================================
// Layer 1: EMA Ribbon Trend Direction
layer1_ribbonLong = bullishRibbon and ribbonStrengthOk and longTermBullish
layer1_ribbonShort = bearishRibbon and ribbonStrengthOk and longTermBearish

// Layer 2: MACD Momentum Confirmation
layer2_macdLong = (useZeroCross and macdZeroCrossUp) or (useSignalCross and macdSignalCrossUp) or macdMomentumUp
layer2_macdShort = (useZeroCross and macdZeroCrossDown) or (useSignalCross and macdSignalCrossDown) or macdMomentumDown

// Layer 3: Volume Confirmation (using previous bar to avoid look-ahead)
avgVolume = ta.sma(volume, 20)
volumePrev = volume[1]
avgVolumePrev = avgVolume[1]
layer3_volumeOk = not useVolumeFilter or volumePrev > avgVolumePrev * volumeThreshold

// Layer 4: Risk Management
var int dailyTrades = 0
newDay = ta.change(dayofweek) != 0
if newDay
    dailyTrades := 0

if strategy.closedtrades > strategy.closedtrades[1]
    dailyTrades := dailyTrades + 1

layer4_riskOk = dailyTrades < maxDailyTrades

// Final Signal Generation
rawLongSignal = layer1_ribbonLong and layer2_macdLong and layer3_volumeOk and layer4_riskOk
rawShortSignal = layer1_ribbonShort and layer2_macdShort and layer3_volumeOk and layer4_riskOk

//=====================================================================================================================
// âš¡ EARLY ENTRY SYSTEM - ENHANCED MULTI-PATH
//=====================================================================================================================
// Dynamic MACD threshold based on user preference
macdThreshold = useAggressiveMacd ? -0.05 : -0.15
oversoldMacdTurning = (macdPrev < macdThreshold) and (macdPrev > macdPrev2)  // MACD turning up from oversold

// PATH 1: Original Early Entry Conditions (Conservative)
earlyBullishSetup = (closePrev > pivotEmaPrev) and (pivotEmaPrev > slowEmaPrev)  // Partial EMA alignment

// Enhanced Reversal Pattern Options
strictBullishReversal = (low[1] < low[2]) and (closePrev > open[1]) and (closePrev > close[2])  // Original strict pattern
simpleBullishReversal = (closePrev > open[1]) and (closePrev > close[2])  // Simpler green candle after decline
ultraBullishReversal = closePrev > close[2]  // Just require close above 2 bars ago
momentumBullishReversal = (closePrev > open[1]) or (high[1] > high[2])  // Either bullish candle OR higher high

// Select reversal pattern based on settings
strongBullishReversal = useUltraEarly ? (momentumBullishReversal or ultraBullishReversal) : (useSimpleReversal ? simpleBullishReversal : strictBullishReversal)

// PATH 2: Momentum-Based Entry (More Aggressive)
priceAboveFast = closePrev > fastEmaPrev  // Just above fast EMA
fastEmaTrendingUp = fastEmaPrev > fastEma[2]  // Fast EMA trending upward
momentumSetup = priceAboveFast and fastEmaTrendingUp
macdTurningPositive = macdPrev > macdPrev2  // Any upward momentum

// PATH 3: Trend Continuation Entry (Alternative)
trendContinuationSetup = closePrev > pivotEmaPrev  // Price above pivot only
macdBelowZero = macdPrev < 0  // MACD still negative (oversold area)
continuationReversal = useUltraEarly ? ultraBullishReversal : momentumBullishReversal

// PATH 4: Pure Momentum Entry (Ultra-Aggressive)
pureBreakout = closePrev > math.max(high[1], high[2])  // Breaking above recent highs
volumeBurst = useVolumeFilterEarly ? volumePrev > avgVolumePrev * 1.5 : true  // Volume confirmation if enabled

// Early Signal Generation Logic
earlyVolumeOk = useVolumeFilterEarly ? layer3_volumeOk : true

// Multiple early entry paths
earlyPath1 = earlyBullishSetup and strongBullishReversal and oversoldMacdTurning  // Original path
earlyPath2 = useMultiplePaths and momentumSetup and ultraBullishReversal and macdTurningPositive  // Momentum path
earlyPath3 = useMultiplePaths and trendContinuationSetup and continuationReversal and macdBelowZero  // Trend continuation
earlyPath4 = useUltraEarly and pureBreakout and volumeBurst and macdTurningPositive  // Pure momentum breakout

// Combined early long signal
earlyLongSignal = useEarlyEntry and (earlyPath1 or earlyPath2 or earlyPath3 or earlyPath4) and earlyVolumeOk and layer4_riskOk

// BEARISH PATHS (Mirror logic for shorts)
// PATH 1: Original Early Bearish Setup
earlyBearishSetup = (closePrev < pivotEmaPrev) and (pivotEmaPrev < slowEmaPrev)  // Partial EMA alignment
overboughtMacdTurning = (macdPrev > -macdThreshold) and (macdPrev < macdPrev2)  // MACD turning down from overbought

// Enhanced Bearish Reversal Patterns
strictBearishReversal = (high[1] > high[2]) and (closePrev < open[1]) and (closePrev < close[2])  // Original strict pattern
simpleBearishReversal = (closePrev < open[1]) and (closePrev < close[2])  // Simpler red candle after rally
ultraBearishReversal = closePrev < close[2]  // Just require close below 2 bars ago
momentumBearishReversal = (closePrev < open[1]) or (low[1] < low[2])  // Either bearish candle OR lower low

// Select bearish reversal pattern
strongBearishReversal = useUltraEarly ? (momentumBearishReversal or ultraBearishReversal) : (useSimpleReversal ? simpleBearishReversal : strictBearishReversal)

// PATH 2: Bearish Momentum Setup
priceBelowFast = closePrev < fastEmaPrev  // Below fast EMA
fastEmaTrendingDown = fastEmaPrev < fastEma[2]  // Fast EMA trending downward
bearishMomentumSetup = priceBelowFast and fastEmaTrendingDown
macdTurningNegative = macdPrev < macdPrev2  // Any downward momentum

// PATH 3: Bearish Trend Continuation
bearishContinuationSetup = closePrev < pivotEmaPrev  // Price below pivot only
macdAboveZero = macdPrev > 0  // MACD still positive (overbought area)
bearishContinuationReversal = useUltraEarly ? ultraBearishReversal : momentumBearishReversal

// PATH 4: Pure Bearish Momentum
pureBreakdown = closePrev < math.min(low[1], low[2])  // Breaking below recent lows

// Bearish early entry paths
earlyBearishPath1 = earlyBearishSetup and strongBearishReversal and overboughtMacdTurning  // Original path
earlyBearishPath2 = useMultiplePaths and bearishMomentumSetup and ultraBearishReversal and macdTurningNegative  // Momentum path
earlyBearishPath3 = useMultiplePaths and bearishContinuationSetup and bearishContinuationReversal and macdAboveZero  // Trend continuation
earlyBearishPath4 = useUltraEarly and pureBreakdown and volumeBurst and macdTurningNegative  // Pure momentum breakdown

// Combined early short signal
earlyShortSignal = useEarlyEntry and (earlyBearishPath1 or earlyBearishPath2 or earlyBearishPath3 or earlyBearishPath4) and earlyVolumeOk and layer4_riskOk

//=====================================================================================================================
// âœ… SIGNAL CONFIRMATION LOGIC
//=====================================================================================================================
// Signal Evolution Tracking - Track RAW early signals for confirmation detection
var int lastRawSignalType = 0  // 0=none, 1=early_long, -1=early_short, 2=standard_long, -2=standard_short
var int lastRawSignalBar = -1
var bool confirmationAlreadyShown = false  // Track if confirmation signal already displayed
var int lastConfirmationBar = -1  // Track when last confirmation was shown
// SIMPLIFIED EARLY SIGNAL SUPPRESSION - Replace complex confirmation system
var int lastEarlySignalDirection = 0  // Track last early signal direction (1=long, -1=short, 0=none)
var int lastEarlySignalBar = -1  // Track when last early signal occurred

// Current bar RAW signal detection (ignores position filters and cooldowns)
currentBarRawEarlyLong = earlyLongSignal
currentBarRawEarlyShort = earlyShortSignal
currentBarRawStandardLong = rawLongSignal
currentBarRawStandardShort = rawShortSignal

//=====================================================================================================================
// âœ… SIMPLIFIED CONFIRMATION & SUPPRESSION SYSTEM
//=====================================================================================================================
// Goal: Eâ†‘ â†’ Câ†‘ â†’ (suppress ALL same direction) â†’ Eâ†“ â†’ Câ†“ â†’ (suppress ALL same direction) - AUTOMATION SAFE

// Step 1: Simple confirmation detection - consecutive early signals in same direction
barsFromLastRawSignal = bar_index - lastRawSignalBar
isWithinConfirmationWindow = barsFromLastRawSignal <= confirmationWindow and barsFromLastRawSignal > 0

// Simple confirmation logic: second early signal in same direction becomes confirmation
// BUT suppress confirmations if we already had one in the same direction (automation safety)
confirmedLongSignal = useSignalConfirmation and currentBarRawEarlyLong and (lastRawSignalType == 1) and isWithinConfirmationWindow and (lastEarlySignalDirection != 1)
confirmedShortSignal = useSignalConfirmation and currentBarRawEarlyShort and (lastRawSignalType == -1) and isWithinConfirmationWindow and (lastEarlySignalDirection != -1)

// Step 2: Track confirmation state for suppression
if confirmedLongSignal
    lastEarlySignalDirection := 1  // Remember we had a long confirmation
    lastEarlySignalBar := bar_index
else if confirmedShortSignal
    lastEarlySignalDirection := -1  // Remember we had a short confirmation
    lastEarlySignalBar := bar_index

// Step 3: Comprehensive suppression after confirmation - NO TIME-BASED RESET
// Suppresses BOTH early signals (E) AND additional confirmations (C) in same direction
// This prevents additional trades in automation until genuine direction change
suppressEarlyLong = (lastEarlySignalDirection == 1) and (lastEarlySignalBar != -1)
suppressEarlyShort = (lastEarlySignalDirection == -1) and (lastEarlySignalBar != -1)
// Note: Confirmation suppression handled above in confirmation logic

// Step 4: Track early signal history for confirmation detection
if currentBarRawEarlyLong
    lastRawSignalType := 1
    lastRawSignalBar := bar_index
else if currentBarRawEarlyShort
    lastRawSignalType := -1
    lastRawSignalBar := bar_index

// Step 5: Reset suppression ONLY on direction change - NO TIME-BASED RESET
// This ensures indefinite suppression until genuine opposite signal for automation safety
if (lastEarlySignalDirection == 1 and currentBarRawEarlyShort) or (lastEarlySignalDirection == -1 and currentBarRawEarlyLong)
    lastEarlySignalDirection := 0  // Reset for new direction
    lastEarlySignalBar := -1

// Signal classification with confirmations restored
upgradedStandardLong = confirmedLongSignal and upgradeConfirmedSignals
upgradedStandardShort = confirmedShortSignal and upgradeConfirmedSignals

// DEBUG: Add confirmation debug plot - positioned below signal triangles
debugConfirmationLong = currentBarRawEarlyLong ? 1 : 0
debugLastSignalType = lastRawSignalType
debugBarsFromLast = barsFromLastRawSignal
debugWithinWindow = isWithinConfirmationWindow ? 1 : 0
debugConfirmedSignal = confirmedLongSignal ? 1 : 0
debugConfirmationState = confirmationAlreadyShown ? 1 : 0
// NOTE: Simplified confirmation system - removed complex canShowConfirmation logic
plot(debugConfirmationLong * -3, "Debug Current Early", color.blue, 2, plot.style_circles)
plot(debugLastSignalType * -0.5, "Debug Last Signal Type", color.purple, 2, plot.style_stepline)
plot(debugBarsFromLast / -10, "Debug Bars From Last (Ã·-10)", color.gray, 1, plot.style_line)
plot(debugWithinWindow * -2, "Debug Within Window", color.orange, 2, plot.style_stepline)
plot(debugConfirmedSignal * -4, "Debug CONFIRMED!", color.lime, 3, plot.style_cross)
plot(debugConfirmationState * -1, "Debug Confirmation State", color.fuchsia, 2, plot.style_stepline)
// NOTE: Suppression debug plots now handled in simplified system below

// Simplified signal classification - no complex upgrading
// upgradedStandardLong and upgradedStandardShort already set above

// DEBUG: Check if upgradedStandardLong is evaluating correctly
plot(upgradedStandardLong ? -5 : na, "Debug Upgraded Standard Long", color.yellow, 4, plot.style_cross)
plot(upgradeConfirmedSignals ? -6 : na, "Debug Upgrade Setting", color.fuchsia, 2, plot.style_circles)

// NOTE: Early signal suppression logic now handled above in simplified system

// Debug plots for indefinite suppression system
debugSuppressEarlyLong = suppressEarlyLong ? 1 : 0
debugSuppressEarlyShort = suppressEarlyShort ? -1 : 0
debugLastEarlyDirection = lastEarlySignalDirection
debugConfirmedLong = confirmedLongSignal ? 1 : 0
debugConfirmedShort = confirmedShortSignal ? -1 : 0
plot(debugSuppressEarlyLong * -7, "Debug Suppress Early Long", color.red, 2, plot.style_stepline)
plot(debugSuppressEarlyShort * -7, "Debug Suppress Early Short", color.maroon, 2, plot.style_stepline)
plot(debugLastEarlyDirection * -8, "Debug Last Early Direction", color.orange, 2, plot.style_stepline)
plot(debugConfirmedLong * -4, "Debug CONFIRMED Long!", color.lime, 3, plot.style_cross)
plot(debugConfirmedShort * -4, "Debug CONFIRMED Short!", color.red, 3, plot.style_cross)

// Final signal determination with simplified early signal suppression
finalStandardLong = rawLongSignal or upgradedStandardLong
finalStandardShort = rawShortSignal or upgradedStandardShort
finalEarlyLong = earlyLongSignal and not upgradedStandardLong and not suppressEarlyLong
finalEarlyShort = earlyShortSignal and not upgradedStandardShort and not suppressEarlyShort

// Combined Signal System (Standard + Early Entry + Confirmed)
combinedLongSignal = finalStandardLong or finalEarlyLong
combinedShortSignal = finalStandardShort or finalEarlyShort

//=====================================================================================================================
// ðŸ”„ SIGNAL FILTERING SYSTEM
//=====================================================================================================================
// Signal Cooldown System - Prevent rapid-fire signals
var int lastLongSignalBar = -999
var int lastShortSignalBar = -999
var int lastSignalBar = -999

//=====================================================================================================================
// ðŸ”„ SIGNAL FILTERING SYSTEM - REFACTORED TO ELIMINATE CIRCULAR DEPENDENCIES
//=====================================================================================================================

// STEP 1: Calculate cooldown periods using PREVIOUS bar timers (breaks circular dependency)
barsFromLastLong = bar_index - lastLongSignalBar
barsFromLastShort = bar_index - lastShortSignalBar
barsFromLastSignal = bar_index - lastSignalBar

// STEP 2: Determine signal types for cooldown calculation (using combined signals, not final)
// This avoids circular dependency since we're not using finalEarlyLong/finalEarlyShort
combinedEarlyLong = earlyLongSignal and not upgradedStandardLong
combinedEarlyShort = earlyShortSignal and not upgradedStandardShort
combinedStandardLong = rawLongSignal or upgradedStandardLong
combinedStandardShort = rawShortSignal or upgradedStandardShort

// STEP 3: Calculate effective cooldown periods
isEarlyLongSignal = combinedEarlyLong and combinedLongSignal
isEarlyShortSignal = combinedEarlyShort and combinedShortSignal
isConfirmedLongSignal = upgradedStandardLong and combinedLongSignal
isConfirmedShortSignal = upgradedStandardShort and combinedShortSignal

effectiveLongCooldown = (isEarlyLongSignal and not isConfirmedLongSignal) ? earlyCooldownBars : standardCooldownBars
effectiveShortCooldown = (isEarlyShortSignal and not isConfirmedShortSignal) ? earlyCooldownBars : standardCooldownBars

// STEP 4: Calculate cooldown filters (no circular dependency)
longCooldownOk = not useSignalCooldown or barsFromLastLong >= effectiveLongCooldown or (allowConfirmationBypass and isConfirmedLongSignal)
shortCooldownOk = not useSignalCooldown or barsFromLastShort >= effectiveShortCooldown or (allowConfirmationBypass and isConfirmedShortSignal)

// STEP 5: Rapid reversal prevention
rapidReversalBlock = preventRapidReversals and barsFromLastSignal < earlyCooldownBars
longReversalOk = not rapidReversalBlock or barsFromLastShort >= earlyCooldownBars
shortReversalOk = not rapidReversalBlock or barsFromLastLong >= earlyCooldownBars

// STEP 6: Signal strength filters (independent of cooldown)
signalStrengthLong = not useSignalStrength or (bullishRibbon and ribbonStrengthOk and longTermBullish and (macdPrev > macdPrev2 or macdPrev > -0.1))
signalStrengthShort = not useSignalStrength or (bearishRibbon and ribbonStrengthOk and longTermBearish and (macdPrev < macdPrev2 or macdPrev < 0.1))

// STEP 7: Market structure filter (independent of cooldown)
sma20 = ta.sma(close, 20)
sma20Prev = sma20[1]
structureLevel = marketStructureMode == "SMA 20" ? sma20Prev : pivotEmaPrev
marketStructureOk = not useMarketStructureFilter or (combinedLongSignal and close[1] > structureLevel) or (combinedShortSignal and close[1] < structureLevel)

// STEP 8: Final signal calculation (NO circular dependency)
finalLongSignal = combinedLongSignal and strategy.position_size <= 0 and longCooldownOk and longReversalOk and signalStrengthLong and marketStructureOk
finalShortSignal = combinedShortSignal and strategy.position_size >= 0 and shortCooldownOk and shortReversalOk and signalStrengthShort and marketStructureOk

//=====================================================================================================================
// ðŸšª SMART EXIT SYSTEM - Reversal Detection & EMA Break Exits
//=====================================================================================================================

// Pre-calculate volume confirmation for reversal patterns
avgVolume20 = ta.sma(volume, 20)
avgVolume20Prev = avgVolume20[1]
volumeConfirmed = not volumeConfirmation or volumePrev > avgVolume20Prev * 1.2

// Pre-calculate ATR for pattern validation (Pine Script v6 requirement)
atr14 = ta.atr(14)
atr14Prev = atr14[1]

// Enhanced Reversal Pattern Detection (using configurable thresholds)
// Calculate candle components for pattern analysis
candleRange = high[1] - low[1]
candleBody = math.abs(close[1] - open[1])
lowerShadow = math.min(open[1], close[1]) - low[1]
upperShadow = high[1] - math.max(open[1], close[1])

// Improved Hammer Pattern: Configurable thresholds for real-world patterns
hammerLowerShadow = lowerShadow >= candleRange * hammerShadowRatio
hammerBodySize = candleBody <= candleRange * bodyToRangeRatio
hammerUpperShadow = upperShadow <= candleRange * upperShadowRatio
hammerMinSize = candleRange > atr14Prev * 0.3  // Minimum significance
hammerPattern = hammerLowerShadow and hammerBodySize and hammerUpperShadow and hammerMinSize

// Improved Shooting Star Pattern: Mirror of hammer logic
shootingStarUpperShadow = upperShadow >= candleRange * hammerShadowRatio
shootingStarBodySize = candleBody <= candleRange * bodyToRangeRatio
shootingStarLowerShadow = lowerShadow <= candleRange * upperShadowRatio
shootingStarMinSize = candleRange > atr14Prev * 0.3
shootingStarPattern = shootingStarUpperShadow and shootingStarBodySize and shootingStarLowerShadow and shootingStarMinSize

// Enhanced Doji Pattern: More flexible body size
dojiBodyRatio = candleBody / candleRange
dojiPattern = dojiBodyRatio <= 0.15 and candleRange > atr14Prev * 0.25  // Relaxed criteria

// Improved Engulfing Patterns: More reliable detection
bullishEngulfingBody = close[1] > open[1] and close[2] < open[2]  // Current green, previous red
bullishEngulfingSize = close[1] > open[2] and open[1] < close[2]  // Bodies overlap significantly
bullishEngulfingVolume = not volumeConfirmation or volumePrev > avgVolume20Prev
bullishEngulfing = bullishEngulfingBody and bullishEngulfingSize and bullishEngulfingVolume

bearishEngulfingBody = close[1] < open[1] and close[2] > open[2]  // Current red, previous green
bearishEngulfingSize = close[1] < open[2] and open[1] > close[2]  // Bodies overlap significantly
bearishEngulfingVolume = not volumeConfirmation or volumePrev > avgVolume20Prev
bearishEngulfing = bearishEngulfingBody and bearishEngulfingSize and bearishEngulfingVolume

// Strong Reversal Patterns: Large body reversals (like 9:15 scenario)
// Strong Bullish Reversal: Large green body with lower shadow at support
strongBullishBody = close[1] > open[1] and candleBody >= candleRange * 0.6  // Large green body (â‰¥60%)
strongBullishShadow = lowerShadow >= candleRange * 0.2  // Some lower shadow (â‰¥20%)
strongBullishUpper = upperShadow <= candleRange * 0.15  // Minimal upper shadow (â‰¤15%)
strongBullishSize = candleRange > atr14Prev * 0.4  // Significant candle size
strongBullPattern = strongBullishBody and strongBullishShadow and strongBullishUpper and strongBullishSize

// Strong Bearish Reversal: Large red body with upper shadow at resistance
strongBearishBody = close[1] < open[1] and candleBody >= candleRange * 0.6  // Large red body (â‰¥60%)
strongBearishShadow = upperShadow >= candleRange * 0.2  // Some upper shadow (â‰¥20%)
strongBearishLower = lowerShadow <= candleRange * 0.15  // Minimal lower shadow (â‰¤15%)
strongBearishSize = candleRange > atr14Prev * 0.4  // Significant candle size
strongBearPattern = strongBearishBody and strongBearishShadow and strongBearishLower and strongBearishSize

// Combine reversal patterns based on sensitivity
conservativeReversal = hammerPattern or shootingStarPattern or strongBullPattern or strongBearPattern
moderateReversal = conservativeReversal or dojiPattern
aggressiveReversal = moderateReversal or bullishEngulfing or bearishEngulfing

// Select reversal pattern based on sensitivity setting
reversalDetected = reversalSensitivity <= 0.4 ? conservativeReversal : reversalSensitivity <= 0.7 ? moderateReversal : aggressiveReversal

// Direction-specific reversal detection
bullishReversalDetected = reversalDetected and (hammerPattern or dojiPattern or bullishEngulfing or strongBullPattern)
bearishReversalDetected = reversalDetected and (shootingStarPattern or dojiPattern or bearishEngulfing or strongBearPattern)

// EMA Break Exit Logic
emaExitPrice = emaExitLevel == "Fast EMA" ? fastEmaPrev : emaExitLevel == "Pivot EMA" ? pivotEmaPrev : slowEmaPrev

// EMA break conditions (using previous bar to avoid repainting)
longEmaBreak = useEmaBreakExits and strategy.position_size > 0 and closePrev < emaExitPrice
shortEmaBreak = useEmaBreakExits and strategy.position_size < 0 and closePrev > emaExitPrice

// Support/Resistance Level Exit Logic (at key psychological levels)
supportLevel = math.floor(close[1] / 1000) * 1000  // Round to nearest $1000
resistanceLevel = math.ceil(close[1] / 1000) * 1000

// Final Smart Exit Conditions
smartExitLong = strategy.position_size > 0 and ((useReversalExits and bearishReversalDetected and volumeConfirmed) or longEmaBreak)
smartExitShort = strategy.position_size < 0 and ((useReversalExits and bullishReversalDetected and volumeConfirmed) or shortEmaBreak)

// Combined exit signal
smartExitSignal = smartExitLong or smartExitShort

//=====================================================================================================================
// ðŸ’¼ POSITION MANAGEMENT
//=====================================================================================================================
var float entryPrice = na
var float stopLossPrice = na
var float takeProfitPrice = na
var float trailingStopPrice = na
var float highestPrice = na
var float lowestPrice = na
var bool trailingActive = false

// Long Position Setup
if finalLongSignal
    entryPrice := open
    stopLossPrice := entryPrice * (1 - stopLossPercent / 100)
    takeProfitPrice := entryPrice * (1 + takeProfitPercent / 100)
    trailingStopPrice := stopLossPrice
    highestPrice := entryPrice
    trailingActive := false

// Short Position Setup
if finalShortSignal
    entryPrice := open
    stopLossPrice := entryPrice * (1 + stopLossPercent / 100)
    takeProfitPrice := entryPrice * (1 - takeProfitPercent / 100)
    trailingStopPrice := stopLossPrice
    lowestPrice := entryPrice
    trailingActive := false

// Long Trailing Stop Logic
if strategy.position_size > 0 and useTrailingStop
    if high > highestPrice
        highestPrice := high

    profitPercent = (highestPrice - entryPrice) / entryPrice * 100
    if profitPercent >= trailingActivation
        trailingActive := true

    if trailingActive
        newTrailingStop = highestPrice * (1 - trailingDistance / 100)
        if newTrailingStop > trailingStopPrice
            trailingStopPrice := newTrailingStop

// Short Trailing Stop Logic
if strategy.position_size < 0 and useTrailingStop
    if low < lowestPrice
        lowestPrice := low

    profitPercent = (entryPrice - lowestPrice) / entryPrice * 100
    if profitPercent >= trailingActivation
        trailingActive := true

    if trailingActive
        newTrailingStop = lowestPrice * (1 + trailingDistance / 100)
        if newTrailingStop < trailingStopPrice
            trailingStopPrice := newTrailingStop

//=====================================================================================================================
// ðŸ“ˆ STRATEGY EXECUTION
//=====================================================================================================================
// Entry Orders with Cooldown Timer Updates
if finalLongSignal
    strategy.entry("EMA_Long", strategy.long, comment="Ribbon+MACD Long")
    // Update cooldown timers ONLY on actual trade execution
    lastLongSignalBar := bar_index
    lastSignalBar := bar_index

if finalShortSignal
    strategy.entry("EMA_Short", strategy.short, comment="Ribbon+MACD Short")
    // Update cooldown timers ONLY on actual trade execution
    lastShortSignalBar := bar_index
    lastSignalBar := bar_index

// Exit Orders
if strategy.position_size > 0
    if useTrailingStop and trailingActive
        strategy.exit("Long_Exit", "EMA_Long", stop=trailingStopPrice, limit=takeProfitPrice, comment="Trailing")
    else
        strategy.exit("Long_Exit", "EMA_Long", stop=stopLossPrice, limit=takeProfitPrice, comment="Fixed")

if strategy.position_size < 0
    if useTrailingStop and trailingActive
        strategy.exit("Short_Exit", "EMA_Short", stop=trailingStopPrice, limit=takeProfitPrice, comment="Trailing")
    else
        strategy.exit("Short_Exit", "EMA_Short", stop=stopLossPrice, limit=takeProfitPrice, comment="Fixed")

// Smart Exit Orders (Override regular exits when reversal detected)
if smartExitLong
    exitReason = longEmaBreak ? "EMA Break" : "Reversal"
    strategy.close("EMA_Long", comment="Smart Exit: " + exitReason)

if smartExitShort
    exitReason = shortEmaBreak ? "EMA Break" : "Reversal"
    strategy.close("EMA_Short", comment="Smart Exit: " + exitReason)

//=====================================================================================================================
// ðŸŽ¨ VISUALIZATION - NON-OVERLAY MULTI-INDICATOR PANE
//=====================================================================================================================
// Note: MACD already calculated above, reusing existing variables

// MACD Plots
macdPlot = plot(macdLine, "MACD Line", color.blue, 3)
signalPlot = plot(signalLine, "Signal Line", color.red, 2)
plot(histogramLine, "Histogram", color.gray, style=plot.style_histogram)
hline(0, "Zero Line", color.black, linestyle=hline.style_solid, linewidth=2)

// MACD Fill
fill(macdPlot, signalPlot, color=macdLine > signalLine ? color.new(color.green, 80) : color.new(color.red, 80), title="MACD Fill")

// Ribbon Strength Indicators (scaled for MACD pane)
ribbonStrengthCombined = (fastPivotGap + pivotSlowGap) / 2  // Average gap strength
ribbonStrengthScaled = ribbonStrengthCombined * 10  // Scale for visibility in MACD pane

// Ribbon Strength Plot
ribbonStrengthColor = ribbonStrengthOk ? color.lime : color.orange
plot(ribbonStrengthScaled, "Ribbon Strength", ribbonStrengthColor, 2, plot.style_area)

// Ribbon Direction Indicator
ribbonDirection = bullishRibbon ? 1 : bearishRibbon ? -1 : 0
ribbonDirectionScaled = ribbonDirection * 0.5  // Scale for MACD pane
ribbonDirColor = bullishRibbon ? color.green : bearishRibbon ? color.red : color.gray
plot(ribbonDirectionScaled, "Ribbon Direction", ribbonDirColor, 3, plot.style_stepline)

// Signal Quality Histogram
signalQuality = (layer1_ribbonLong or layer1_ribbonShort ? 1 : 0) + (layer2_macdLong or layer2_macdShort ? 1 : 0) + (layer3_volumeOk ? 1 : 0) + (layer4_riskOk ? 1 : 0)
signalQualityScaled = signalQuality * 0.25  // Scale 0-1 range
signalQualityColor = signalQuality >= 3 ? color.lime : signalQuality >= 2 ? color.yellow : color.red
plot(signalQualityScaled, "Signal Quality", signalQualityColor, 1, plot.style_columns)

// Reference lines for ribbon strength
hline(minRibbonGap * 10, "Min Ribbon Gap", color.orange, linestyle=hline.style_dotted)
hline(0.5, "Ribbon Strong", color.lime, linestyle=hline.style_dashed)

// Volume Strength (scaled to fit)
volumeStrength = volumePrev > avgVolumePrev * volumeThreshold ? 0.8 : 0.2
plot(volumeStrength, "Volume Strength", color.purple, 1, plot.style_stepline)

// Enhanced Signal Display with Confirmation System
// Standard/Confirmed Signals
plotshape(finalStandardLong and not upgradedStandardLong, title="Standard Long", style=shape.triangleup, location=location.bottom, color=standardLongColor, size=size.small, text="LONG")
plotshape(finalStandardShort and not upgradedStandardShort, title="Standard Short", style=shape.triangledown, location=location.bottom, color=standardShortColor, size=size.small, text="SHORT")

// Confirmed Signals (upgraded from consecutive early signals)
plotshape(upgradedStandardLong, title="Confirmed Long", style=shape.triangleup, location=location.bottom, color=standardLongColor, size=size.small, text="C")
plotshape(upgradedStandardShort, title="Confirmed Short", style=shape.triangledown, location=location.bottom, color=standardShortColor, size=size.small, text="C")

// Early Entry Signals (only show non-confirmed early signals)
plotshape(finalEarlyLong and strategy.position_size <= 0, title="Early Long", style=shape.triangleup, location=location.bottom, color=earlyLongColor, size=size.tiny, text="E")
plotshape(finalEarlyShort and strategy.position_size >= 0, title="Early Short", style=shape.triangledown, location=location.bottom, color=earlyShortColor, size=size.tiny, text="E")

// Signal labels removed for cleaner chart visualization
// Signals are now indicated purely by triangle shapes and colors

// Position Background
bgcolor(strategy.position_size > 0 ? color.new(color.green, 97) : strategy.position_size < 0 ? color.new(color.red, 97) : na)

// Stop Loss and Take Profit Lines
longStopPlot = strategy.position_size > 0 ? (useTrailingStop and trailingActive ? trailingStopPrice : stopLossPrice) : na
longTpPlot = strategy.position_size > 0 ? takeProfitPrice : na
shortStopPlot = strategy.position_size < 0 ? (useTrailingStop and trailingActive ? trailingStopPrice : stopLossPrice) : na
shortTpPlot = strategy.position_size < 0 ? takeProfitPrice : na

plot(longStopPlot, "Long Stop", color.red, 2, plot.style_linebr)
plot(longTpPlot, "Long TP", color.green, 2, plot.style_linebr)
plot(shortStopPlot, "Short Stop", color.red, 2, plot.style_linebr)
plot(shortTpPlot, "Short TP", color.green, 2, plot.style_linebr)

//=====================================================================================================================
// ðŸ“Š ORGANIZED DEBUG DASHBOARD
//=====================================================================================================================
if barstate.islast
    // Calculate how many debug categories are enabled
    totalCategories = (showPerformance ? 1 : 0) + (showSignalStatus ? 1 : 0) + (showFilters ? 1 : 0) + (showLayerBreakdown ? 1 : 0) + (showSmartExit ? 1 : 0) + (showPatterns ? 1 : 0) + (showPosition ? 1 : 0)

    // Only show table if at least one category is enabled
    if totalCategories > 0
        // Use fixed large table size to prevent bounds errors
        maxRows = 30
        
        // Delete existing table and create fresh one to prevent duplicates
        var table perfTable = na
        if not na(perfTable)
            table.delete(perfTable)
        perfTable := table.new(position.bottom_right, 2, maxRows, bgcolor=color.white, border_width=2)

        // Header
        table.cell(perfTable, 0, 0, "ðŸŽ¯ RIBBON MACD", text_color=color.white, bgcolor=color.navy)
        table.cell(perfTable, 1, 0, "DEBUG", text_color=color.white, bgcolor=color.navy)

        var int rowIndex = 1

        // Performance Metrics (always first when enabled)
        if showPerformance
            winRate = strategy.wintrades / math.max(strategy.closedtrades, 1) * 100

            table.cell(perfTable, 0, rowIndex, "Total Trades", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, str.tostring(strategy.closedtrades), text_color=strategy.closedtrades > 0 ? color.green : color.gray)
            rowIndex += 1

            table.cell(perfTable, 0, rowIndex, "Win Rate", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, str.tostring(winRate, "#.#") + "%", text_color=winRate > 60 ? color.green : color.red)
            rowIndex += 1

            table.cell(perfTable, 0, rowIndex, "Net Profit", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, str.tostring(strategy.netprofit, "$#,###"), text_color=strategy.netprofit > 0 ? color.green : color.red)
            rowIndex += 1

        // Signal Status
        if showSignalStatus
            ribbonStatus = bullishRibbon ? "BULLISH" : bearishRibbon ? "BEARISH" : "MIXED"
            ribbonColor = bullishRibbon ? color.green : bearishRibbon ? color.red : color.orange
            table.cell(perfTable, 0, rowIndex, "EMA Ribbon", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, ribbonStatus, text_color=ribbonColor)
            rowIndex += 1

            macdStatus = macdPrev > 0 ? "BULL" : "BEAR"
            macdColor = macdPrev > 0 ? color.green : color.red
            table.cell(perfTable, 0, rowIndex, "MACD Status", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, macdStatus, text_color=macdColor)
            rowIndex += 1

            smaStatus = sma50 > sma200 ? "BULLISH" : "BEARISH"
            smaColor = sma50 > sma200 ? color.green : color.red
            table.cell(perfTable, 0, rowIndex, "SMA Context", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, smaStatus, text_color=smaColor)
            rowIndex += 1

        // Layer Breakdown Debug
        if showLayerBreakdown
            layer1Status = layer1_ribbonLong ? "LONGâœ“" : layer1_ribbonShort ? "SHORTâœ“" : "FAIL"
            layer1Color = layer1_ribbonLong ? color.green : layer1_ribbonShort ? color.red : color.orange
            table.cell(perfTable, 0, rowIndex, "Layer 1 (EMA)", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, layer1Status, text_color=layer1Color)
            rowIndex += 1

            layer2Status = layer2_macdLong ? "LONGâœ“" : layer2_macdShort ? "SHORTâœ“" : "FAIL"
            layer2Color = layer2_macdLong ? color.green : layer2_macdShort ? color.red : color.orange
            table.cell(perfTable, 0, rowIndex, "Layer 2 (MACD)", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, layer2Status, text_color=layer2Color)
            rowIndex += 1

            layer3Status = layer3_volumeOk ? "PASSâœ“" : "FAIL"
            layer3Color = layer3_volumeOk ? color.green : color.red
            table.cell(perfTable, 0, rowIndex, "Layer 3 (Volume)", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, layer3Status, text_color=layer3Color)
            rowIndex += 1

            layer4Status = layer4_riskOk ? "PASSâœ“" : "FAIL"
            layer4Color = layer4_riskOk ? color.green : color.red
            table.cell(perfTable, 0, rowIndex, "Layer 4 (Risk)", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, layer4Status, text_color=layer4Color)
            rowIndex += 1

        // Filter Debug
        if showFilters
            signalText = combinedLongSignal ? (finalStandardLong ? (upgradedStandardLong ? "CONFIRMED" : "LONG") : earlyPath1 ? "E-1" : earlyPath2 ? "E-2" : earlyPath3 ? "E-3" : "E-4") : combinedShortSignal ? (finalStandardShort ? (upgradedStandardShort ? "CONFIRMED" : "SHORT") : earlyBearishPath1 ? "E-1" : earlyBearishPath2 ? "E-2" : earlyBearishPath3 ? "E-3" : "E-4") : "WAIT"
            signalColor = combinedLongSignal ? (finalStandardLong ? (upgradedStandardLong ? color.lime : color.green) : color.yellow) : combinedShortSignal ? (finalStandardShort ? (upgradedStandardShort ? color.fuchsia : color.red) : color.orange) : color.gray
            table.cell(perfTable, 0, rowIndex, "Signal Ready", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, signalText, text_color=signalColor)
            rowIndex += 1

            // FIXED: Use actual cooldown logic to determine display - matches strategy execution logic
            // Determine what type of signal would be generated to show accurate cooldown
            currentSignalIsEarlyLong = isEarlyLongSignal and not isConfirmedLongSignal
            currentSignalIsEarlyShort = isEarlyShortSignal and not isConfirmedShortSignal
            currentSignalIsEarly = currentSignalIsEarlyLong or currentSignalIsEarlyShort
            
            // Use the same cooldown logic as the actual strategy
            effectiveCooldownForDisplay = currentSignalIsEarly ? earlyCooldownBars : standardCooldownBars
            signalTypeForDisplay = currentSignalIsEarly ? "Early" : "Standard"
            cooldownText = useSignalCooldown ? (barsFromLastSignal >= effectiveCooldownForDisplay ? "READY" : str.tostring(effectiveCooldownForDisplay - barsFromLastSignal) + " bars (" + signalTypeForDisplay + ")") : "OFF"
            cooldownColor = useSignalCooldown ? (barsFromLastSignal >= effectiveCooldownForDisplay ? color.green : color.orange) : color.gray
            table.cell(perfTable, 0, rowIndex, "Signal Cooldown", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, cooldownText, text_color=cooldownColor)
            rowIndex += 1

            filterText = finalLongSignal ? "LONG OK" : finalShortSignal ? "SHORT OK" : combinedLongSignal ? "LONG BLOCKED" : combinedShortSignal ? "SHORT BLOCKED" : "NONE"
            filterColor = finalLongSignal ? color.green : finalShortSignal ? color.red : (combinedLongSignal or combinedShortSignal) ? color.orange : color.gray
            table.cell(perfTable, 0, rowIndex, "Filter Status", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, filterText, text_color=filterColor)
            rowIndex += 1

        // Smart Exit Debug
        if showSmartExit
            smartExitText = smartExitSignal ? (longEmaBreak or shortEmaBreak ? "EMA BREAK" : "REVERSAL") : (useReversalExits or useEmaBreakExits) ? "MONITORING" : "OFF"
            smartExitColor = smartExitSignal ? color.orange : (useReversalExits or useEmaBreakExits) ? color.blue : color.gray
            table.cell(perfTable, 0, rowIndex, "Smart Exit", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, smartExitText, text_color=smartExitColor)
            rowIndex += 1

            reversalText = reversalDetected ? (bullishReversalDetected ? "BULLISH" : "BEARISH") : "NONE"
            reversalColor = bullishReversalDetected ? color.green : bearishReversalDetected ? color.red : color.gray
            table.cell(perfTable, 0, rowIndex, "Reversal Alert", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, reversalText, text_color=reversalColor)
            rowIndex += 1

        // Pattern Debug
        if showPatterns
            patternDebugText = hammerPattern ? "HAMMER" : strongBullPattern ? "STRONG-BULL" : strongBearPattern ? "STRONG-BEAR" : shootingStarPattern ? "SHOOTING" : dojiPattern ? "DOJI" : bullishEngulfing ? "BULL-ENG" : bearishEngulfing ? "BEAR-ENG" : "NO-MATCH"
            patternDebugColor = (hammerPattern or strongBullPattern or strongBearPattern or shootingStarPattern or dojiPattern or bullishEngulfing or bearishEngulfing) ? color.green : color.orange
            table.cell(perfTable, 0, rowIndex, "Pattern Debug", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, patternDebugText, text_color=patternDebugColor)
            rowIndex += 1

            ratioText = "L:" + str.tostring(lowerShadow/candleRange, "#.##") + " B:" + str.tostring(candleBody/candleRange, "#.##") + " U:" + str.tostring(upperShadow/candleRange, "#.##")
            table.cell(perfTable, 0, rowIndex, "Candle Ratios", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, ratioText, text_color=color.blue)
            rowIndex += 1

            volumeDebugText = volumeConfirmed ? "CONFIRMED" : volumeConfirmation ? "BLOCKED" : "BYPASSED"
            volumeDebugColor = volumeConfirmed ? color.green : volumeConfirmation ? color.red : color.blue
            table.cell(perfTable, 0, rowIndex, "Volume Check", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, volumeDebugText, text_color=volumeDebugColor)
            rowIndex += 1

        // Position Management
        if showPosition
            posText = strategy.position_size > 0 ? "LONG" : strategy.position_size < 0 ? "SHORT" : "FLAT"
            posColor = strategy.position_size > 0 ? color.green : strategy.position_size < 0 ? color.red : color.gray
            table.cell(perfTable, 0, rowIndex, "Position", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, posText, text_color=posColor)
            rowIndex += 1

            table.cell(perfTable, 0, rowIndex, "Daily Trades", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, str.tostring(dailyTrades) + "/" + str.tostring(maxDailyTrades), text_color=dailyTrades < maxDailyTrades ? color.green : color.red)
            rowIndex += 1

            trailText = useTrailingStop and trailingActive ? "ACTIVE" : useTrailingStop ? "WAITING" : "OFF"
            trailColor = useTrailingStop and trailingActive ? color.orange : useTrailingStop ? color.blue : color.gray
            table.cell(perfTable, 0, rowIndex, "Trailing Stop", text_color=color.black)
            table.cell(perfTable, 1, rowIndex, trailText, text_color=trailColor)
            rowIndex += 1

//=====================================================================================================================
// ðŸš¨ ALERTS
//=====================================================================================================================
// Final Filtered Alerts (only fire when signals pass all filters)
if finalLongSignal
    signalType = finalStandardLong ? (upgradedStandardLong ? "Confirmed" : "Standard") : earlyPath1 ? "E-Conservative" : earlyPath2 ? "E-Momentum" : earlyPath3 ? "E-Trend-Continuation" : "E-Ultra-Breakout"
    alert("ðŸŽ¯ LONG Signal (" + signalType + ") - All filters passed", alert.freq_once_per_bar)

if finalShortSignal
    signalType = finalStandardShort ? (upgradedStandardShort ? "Confirmed" : "Standard") : earlyBearishPath1 ? "E-Conservative" : earlyBearishPath2 ? "E-Momentum" : earlyBearishPath3 ? "E-Trend-Continuation" : "E-Ultra-Breakdown"
    alert("ðŸŽ¯ SHORT Signal (" + signalType + ") - All filters passed", alert.freq_once_per_bar)

// Filtered Signal Alert (when raw signals are blocked)
if (combinedLongSignal and not finalLongSignal) or (combinedShortSignal and not finalShortSignal)
    blockReason = not longCooldownOk or not shortCooldownOk ? "Cooldown" : not longReversalOk or not shortReversalOk ? "Rapid-Reversal" : not signalStrengthLong or not signalStrengthShort ? "Weak-Signal" : "Market-Structure"
    alert("âš ï¸ Signal Blocked - Reason: " + blockReason, alert.freq_once_per_bar)

if trailingActive and not trailingActive[1]
    alert("ðŸ“ˆ Trailing stop activated - profits protected", alert.freq_once_per_bar)

// Smart Exit Alerts
if smartExitLong
    exitType = longEmaBreak ? "EMA Break" : "Reversal Pattern"
    alert("ðŸšª Smart Exit LONG - " + exitType + " detected", alert.freq_once_per_bar)

if smartExitShort
    exitType = shortEmaBreak ? "EMA Break" : "Reversal Pattern"
    alert("ðŸšª Smart Exit SHORT - " + exitType + " detected", alert.freq_once_per_bar)

// Reversal Detection Alerts (early warning)
if reversalDetected and volumeConfirmed and not smartExitSignal
    reversalType = hammerPattern ? "Hammer" : strongBullishReversal ? "Strong Bullish" : strongBearishReversal ? "Strong Bearish" : dojiPattern ? "Doji" : bullishEngulfing ? "Bullish Engulfing" : bearishEngulfing ? "Bearish Engulfing" : shootingStarPattern ? "Shooting Star" : "Pattern"
    reversalDirection = bullishReversalDetected ? "BULLISH" : "BEARISH"
    alert("âš ï¸ " + reversalDirection + " Reversal Pattern: " + reversalType + " - Monitor position", alert.freq_once_per_bar)

//=====================================================================================================================
// ðŸ§ª EXPERIMENTAL DEVELOPMENT NOTES
//=====================================================================================================================
// Development Status: v1.4.3 Complete Signal Suppression - E and C Signals
// Target Improvements:
// 1. Enhanced trend filtering via EMA ribbon system
// 2. Reduced false signals through multi-layer confirmation
// 3. Better institutional context via SMA 50/100/200 analysis
// 4. Improved signal quality through ribbon strength filtering
// 5. âœ… Multi-path early entry system for better opportunity capture
// 6. âœ… Signal filtering system to prevent rapid-fire signals and overtrading
// 7. âœ… NEW: Smart Exit System with reversal detection and EMA break exits
//
// Recent Updates (v1.4.3):
// - ðŸš« COMPLETE SUPPRESSION: Now suppresses BOTH "E" early signals AND "C" confirmation signals
// - ðŸŽ¯ SINGLE SIGNAL RULE: Only one Eâ†’C sequence per direction - perfect for automation
// - ðŸ”’ CONFIRMATION LOCK: Prevents multiple confirmations in same direction
// - ðŸ¤– AUTOMATION PERFECT: Absolutely no redundant signals that could trigger unwanted trades
// - ðŸ’° MAXIMUM SAFETY: Complete protection against over-trading in automated systems
// - ðŸ“Š CLEAN PATTERN: Eâ†‘ â†’ Câ†‘ â†’ (suppress ALL) â†’ Eâ†“ â†’ Câ†“ â†’ (suppress ALL)
//
// Previous Updates (v1.4.2):
// - ðŸ¤– AUTOMATION SAFETY: Removed time-based reset - suppression now indefinite until direction change
// - ðŸš« NO REDUNDANT SIGNALS: Prevents additional trades in same direction that could cause losses
// - ðŸ”’ DIRECTION LOCK: Eâ†‘ â†’ Câ†‘ â†’ (suppress indefinitely) â†’ Eâ†“ â†’ Câ†“ â†’ (suppress indefinitely)
// - ðŸ’° PROFIT PROTECTION: Eliminates unnecessary signals that could trigger unwanted trades
// - ðŸŽ¯ CLEAN AUTOMATION: Only one signal per direction change - perfect for automated trading
// - ðŸ“Š SIMPLIFIED DEBUG: Removed time-based plots, focus on direction and suppression state
//
// Previous Updates (v1.4.1):
// - âœ… CONFIRMATION RESTORED: Re-implemented Eâ†’C signal progression with simplified logic
// - ðŸŽ¯ CORRECT BEHAVIOR: Now follows expected pattern Eâ†‘ â†’ Câ†‘ (suppress) â†’ Eâ†“ â†’ Câ†“ (suppress)
// - ðŸ”§ SIMPLIFIED LOGIC: 6-step process that's easy to understand and debug
// - ðŸš« POST-CONFIRMATION SUPPRESSION: Suppresses additional signals for 10 bars after confirmation
// - ðŸ”„ CLEAN RESETS: Automatic reset on direction change or window expiry
// - ðŸ“Š ENHANCED DEBUG: Shows confirmation detection and suppression state clearly
// - ðŸ’¡ MAINTAINABLE: Simple step-by-step logic eliminates complex state management bugs
//
// Previous Updates (v1.4.0) - MAJOR SIMPLIFICATION:
// - ðŸ”¥ SYSTEM REWRITE: Completely replaced complex confirmation/suppression system with simple approach
// - ðŸš« DIRECT SUPPRESSION: Now directly suppresses additional "E" signals in same direction for 8 bars
// - ðŸŽ¯ ELIMINATION: Removed complex confirmation signal generation, state tracking, and reset logic
// - ðŸ“Š SIMPLE TRACKING: Only tracks last early signal direction and timing
// - ðŸ”„ CLEAN RESET: Automatic reset on direction change or window expiry
// - ðŸ’¡ RELIABLE: Simple logic eliminates the bugs that plagued the complex system
// - ðŸŽ›ï¸ MAINTENANCE: Much easier to debug and maintain with fewer moving parts
// - âœ… EFFECTIVE: Achieves the same goal (suppress redundant E signals) with minimal complexity
//
// Previous Updates (v1.3.2):
// - ðŸ› CRITICAL FIX: Fixed suppression logic failure - lastConfirmationDirection now properly resets
// - ðŸ”„ STATE RESET: Added comprehensive state reset when suppression window expires
// - ðŸŽ¯ LOGIC COMPLETION: Suppression now works correctly for full signal cycles (E â†’ C â†’ suppressed Es)
// - ðŸ“Š ENHANCED DEBUG: Added tracking for confirmation direction and bars from last confirmation
// - ðŸš« REDUNDANCY ELIMINATION: Properly prevents redundant "E" signals after "C" confirmations
// - ðŸ’¡ CYCLE MANAGEMENT: Ensures clean state reset for next confirmation/suppression cycle
//
// Previous Updates (v1.3.1):
// - ðŸ› DEBUG FIX: Fixed cooldown display in debug dashboard to show accurate countdown
// - ðŸŽ¯ LOGIC ALIGNMENT: Dashboard now uses same cooldown logic as actual strategy execution
// - ðŸ“Š ENHANCED DISPLAY: Shows signal type (Early/Standard) alongside cooldown countdown
// - ðŸ” USER CLARITY: Eliminates confusion where dashboard showed different cooldown than actual strategy
// - âœ… VALIDATION TOOL: Debug dashboard now reliable for understanding when trades will execute
//
// Previous Updates (v1.3.0) - MAJOR REFACTORING:
// - ðŸ—ï¸ STRUCTURAL OVERHAUL: Completely rebuilt signal filtering system to eliminate circular dependencies
// - ðŸ”„ LOGIC REORDER: Proper sequential flow - cooldown â†’ signal type â†’ filters â†’ final signals
// - ðŸŽ¯ COOLDOWN FIX: Timer updates moved to actual trade execution, not signal calculation
// - ðŸ“Š DEPENDENCY ELIMINATION: Removed circular references between finalLongSignal and longCooldownOk
// - ðŸš« REDUNDANCY REMOVAL: Eliminated duplicate calculations and misplaced code
// - ðŸ”§ PROPER SEPARATION: Independent calculation of cooldown periods, signal types, and filters
// - ðŸ’¡ TRADE EXECUTION: Cooldown timers now update only when trades are actually executed
// - ðŸŽ›ï¸ MAINTAINABILITY: Clear step-by-step filtering process for easier debugging and maintenance
//
// Previous Updates (v1.2.6):
// - ðŸ› CRITICAL FIX: Fixed signal cooldown logic bug - timers now update only on actual trade execution
// - ðŸ”§ LOGIC FIX: Decoupled market structure filter from signal strength filter
// - ðŸŽ›ï¸ NEW INPUT: Added independent "Enable Market Structure Filter" toggle
// - ðŸ“Š TIMER ACCURACY: Cooldown periods now function correctly without perpetual reset
// - ðŸŽ¯ FILTER INDEPENDENCE: Users can now disable signal strength while keeping market structure filter
// - ðŸ’¡ TRADE EXECUTION: Strategy will now properly execute trades after cooldown periods expire
//
// Previous Updates (v1.2.5):
// - ðŸš« EARLY SUPPRESSION: Suppress redundant "E" signals after "C" confirmation signals in same direction
// - ðŸ“Š DIRECTION TRACKING: Added lastConfirmationDirection to track confirmation signal direction
// - â° SUPPRESSION WINDOW: Early signals suppressed for confirmation window + 2 bars
// - ðŸ”„ SMART RESET: Suppression resets on direction change or when window expires
// - ðŸŽ¯ NOISE REDUCTION: Eliminates redundant early signals while preserving confirmation logic
// - ðŸ” ENHANCED DEBUG: Added suppression debug plots for better analysis
//
// Previous Updates (v1.2.4):
// - ðŸ”§ ENHANCED SUPPRESSION: Improved confirmation signal suppression with dual tracking
// - ðŸ“Š TIMING PROTECTION: Added lastConfirmationBar tracking to prevent rapid-fire confirmations
// - ðŸŽ¯ RACE CONDITION FIX: Separated confirmation state updates from signal evaluation
// - ðŸ” IMPROVED DEBUG: Added canShowConfirmation debug plot for better analysis
// - ðŸ“ˆ ROBUST LOGIC: More reliable single confirmation per early signal sequence
// - ðŸš€ PERFORMANCE: Reduced visual clutter while maintaining all confirmation logic
//
// Previous Updates (v1.2.3):
// - ðŸ”‡ CONFIRMATION SUPPRESSION: Prevents multiple 'C' confirmation signals in close succession
// - ðŸ“Š STATE TRACKING: Added confirmationAlreadyShown variable to track confirmation display state
// - ðŸ”„ SMART RESET: Confirmation state resets on direction change, standard signals, or window expiry
// - ðŸŽ¯ CLEANER SIGNALS: Only shows first confirmation signal per early signal sequence
// - ðŸš€ ENHANCED UX: Reduces visual clutter and improves signal clarity on charts
//
// Previous Updates (v1.2.2):
// - ðŸ†• STRONG REVERSAL PATTERNS: Added Strong Bullish/Bearish Reversal detection
// - ðŸ“Š PATTERN CRITERIA: Large body (â‰¥60%) + shadow (â‰¥20%) + minimal opposite shadow (â‰¤15%)
// - ðŸŽ¯ 9:15 SCENARIO: Specifically targets patterns like L:0.32 B:0.68 U:0.0 reversal
// - ðŸ” ENHANCED DEBUG: Pattern Debug shows specific pattern type detected
// - âš¡ CONSERVATIVE TIER: Strong patterns included in conservative sensitivity level
// - ðŸš¨ ALERT INTEGRATION: Strong reversal alerts with pattern type identification
// - ðŸ’ª REAL-WORLD EFFECTIVENESS: Captures marubozu-style reversals at key levels

// Previous Updates (v1.2.1):
// - ðŸ”§ CALIBRATED: Reversal pattern detection thresholds for real-world effectiveness
// - ðŸŽ›ï¸ USER CONTROLS: Configurable pattern ratios (Hammer Shadow, Body Size, Upper Shadow)
// - ðŸ” DEBUG SYSTEM: Optional pattern detection debugging with detailed breakdown
// - ðŸ“Š ENHANCED DETECTION: Improved hammer pattern criteria (0.6â†’0.4 shadow, 0.3â†’0.4 body)
// - âš™ï¸ VOLUME FLEXIBILITY: Volume confirmation now optional (default OFF for testing)
// - ðŸ”¬ PATTERN ANALYSIS: Detailed candle component analysis and ratio display
// - ðŸŽ¯ REAL-WORLD READY: Calibrated against actual market patterns (9:15 hammer scenario)

// Previous Updates (v1.2):
// - Implemented comprehensive Smart Exit System with reversal pattern detection
// - Added 5 reversal patterns: Hammer, Doji, Shooting Star, Bullish/Bearish Engulfing
// - Configurable reversal sensitivity (Conservative, Moderate, Aggressive)
// - EMA break exit logic with selectable EMA levels (Fast/Pivot/Slow)
// - Volume confirmation for reversal patterns (1.2x average volume)
// - Enhanced dashboard with Smart Exit and Reversal Alert status
// - Comprehensive alert system for exits and early reversal warnings
// - Prevents major drawdowns through technical reversal protection
//
// Previous Updates (v1.1):
// - Added 4 different early entry paths (Conservative, Momentum, Trend-Continuation, Ultra-Breakout)
// - Implemented signal cooldown system (default 5 bars minimum between signals)
// - Added rapid reversal prevention (blocks opposite signals too quickly)
// - Integrated signal strength filtering for quality control
//
// Critical Problems Solved:
// - âœ… Reversal Exit Protection: Addresses $800+ adverse moves through pattern detection
// - âœ… EMA Break Exits: Systematic exits when price breaks key support/resistance EMAs
// - âœ… Early Warning System: Reversal alerts before position becomes at risk
// - âœ… Configurable Sensitivity: User control over conservative vs aggressive exit timing
//
// Testing Requirements:
// - Comprehensive test suite validation â‰¥90%
// - Paper trading validation (30+ days)
// - Performance comparison vs pure MACD system
// - Smart exit system effectiveness validation against known scenarios
// - Risk reduction measurement (drawdown protection)
// - Graduation criteria assessment for main repository
//=====================================================================================================================
